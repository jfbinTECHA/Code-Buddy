#!/usr/bin/env python3
import requests, time, os, socket, sys, json
import subprocess
from tabulate import tabulate
from colorama import Fore, Style, init

init(autoreset=True)

# Determine base paths safely no matter where Kilo launches from
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
OPS_DIR = os.path.join(BASE_DIR, "ops")
CONFIG_PATH = os.path.join(BASE_DIR, "config", "health_config.json")
RECOVERY_SCRIPT = os.path.join(OPS_DIR, "recover_bytebot.sh")

def load_health_config():
    if not os.path.exists(CONFIG_PATH):
        raise FileNotFoundError(f"Health config missing: {CONFIG_PATH}")
    with open(CONFIG_PATH) as f:
        return json.load(f)

def run_recovery(failed_services):
    if not os.path.exists(RECOVERY_SCRIPT):
        raise FileNotFoundError(f"Recovery script missing: {RECOVERY_SCRIPT}")
    cmd = [RECOVERY_SCRIPT] + failed_services if failed_services else [RECOVERY_SCRIPT]
    subprocess.run(cmd, check=True)

SERVICES = {
    "bytebot-ui":      "http://localhost:9992/health",
    "bytebot-agent":   "http://localhost:9991/health",
    "postgres":        "http://localhost:5432",
    "redis":           "redis://localhost:6379",
    "chroma":          "http://localhost:8001/api/v1/health"
}

TIMEOUT = 2

def check_http(url):
    try:
        start = time.time()
        r = requests.get(url, timeout=TIMEOUT)
        elapsed = (time.time() - start) * 1000
        if r.status_code == 200:
            return ("OK", f"{elapsed:.0f} ms")
        return ("FAIL", f"HTTP {r.status_code}")
    except Exception as e:
        return ("FAIL", str(e).split()[0])

def check_redis(host, port):
    import redis
    try:
        start = time.time()
        r = redis.Redis(host=host, port=port, socket_timeout=TIMEOUT)
        pong = r.ping()
        elapsed = (time.time() - start) * 1000
        return ("OK", f"{elapsed:.0f} ms" if pong else "FAIL")
    except Exception as e:
        return ("FAIL", str(e).split()[0])

def check_port(host, port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(TIMEOUT)
    try:
        start = time.time()
        s.connect((host, port))
        elapsed = (time.time() - start) * 1000
        s.close()
        return ("OK", f"{elapsed:.0f} ms")
    except Exception as e:
        return ("FAIL", str(e).split()[0])

def main():
    print("\nü©∫  Bytebot Unified Health Summary\n")
    rows = []
    all_ok = True
    failed_services = []

    for name, url in SERVICES.items():
        if url.startswith("http"):
            status, latency = check_http(url)
        elif url.startswith("redis://"):
            host, port = url.replace("redis://", "").split(":")
            status, latency = check_redis(host, int(port))
        else:
            host, port = url.replace("http://", "").split(":")
            status, latency = check_port(host, int(port))

        emoji = "üü¢" if status == "OK" else "üî¥"
        color = Fore.GREEN if status == "OK" else Fore.RED
        rows.append([emoji, name, color + status + Style.RESET_ALL, latency])
        if status != "OK":
            all_ok = False
            failed_services.append(f"- {name} ({latency})")

    print(tabulate(rows, headers=["", "Service", "Status", "Latency"], tablefmt="fancy_grid"))
    print("\n" + ("‚úÖ All services healthy!" if all_ok else "‚ö†Ô∏è  Some services failed."))

    # Optional: Discord/Webhook alerting for failures
    if not all_ok:
        webhook_url = os.getenv("BYTEBOT_DISCORD_WEBHOOK")
        if webhook_url:
            try:
                embed = {
                    "title": "‚ö†Ô∏è Bytebot Health Alert",
                    "color": 15158332,  # red
                    "fields": [
                        {"name": "Failed Services", "value": "\n".join(failed_services), "inline": False},
                    ],
                    "footer": {"text": "Auto-generated by Bytebot Health Monitor"}
                }
                requests.post(webhook_url, json={"embeds": [embed]}, timeout=5)
                print("üì¢ Alert sent to Discord.")
            except Exception as e:
                print(f"‚ö†Ô∏è  Failed to send Discord alert: {e}")

        # Trigger recovery for failed services
        failed_service_names = [name for name, url in SERVICES.items() if any(name in fs for fs in failed_services)]
        if failed_service_names:
            try:
                run_recovery(failed_service_names)
                print(f"üîÑ Recovery triggered for: {', '.join(failed_service_names)}")
            except subprocess.CalledProcessError as e:
                print(f"‚ö†Ô∏è  Recovery failed: {e}")

    sys.exit(0 if all_ok else 1)

if __name__ == "__main__":
    main()