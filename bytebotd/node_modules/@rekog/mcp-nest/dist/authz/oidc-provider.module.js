"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var McpOidcProviderModule_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.McpOidcProviderModule = exports.DEFAULT_OIDC_OPTIONS = void 0;
const common_1 = require("@nestjs/common");
const config_1 = require("@nestjs/config");
const jwt_1 = require("@nestjs/jwt");
const passport_1 = require("@nestjs/passport");
const typeorm_1 = require("@nestjs/typeorm");
const nest_oidc_provider_1 = require("nest-oidc-provider");
const jwt_auth_guard_1 = require("./guards/jwt-auth.guard");
const client_service_1 = require("./services/client.service");
const jwt_token_service_1 = require("./services/jwt-token.service");
const oauth_strategy_service_1 = require("./services/oauth-strategy.service");
const memory_store_service_1 = require("./stores/memory-store.service");
const entities_1 = require("./stores/typeorm/entities");
const typeorm_store_service_1 = require("./stores/typeorm/typeorm-store.service");
const oidc_provider_controller_1 = require("./oidc-provider.controller");
const resource_metadata_controller_1 = require("./controllers/resource-metadata.controller");
const well_known_controller_1 = require("./controllers/well-known.controller");
const github_adapter_1 = require("./adapters/github.adapter");
const oidc_adapter_1 = require("./adapters/oidc.adapter");
exports.DEFAULT_OIDC_OPTIONS = {
    serverUrl: 'https://localhost:3000',
    resource: 'https://localhost:3000/mcp',
    jwtIssuer: 'https://localhost:3000',
    jwtAudience: 'mcp-client',
    jwtAccessTokenExpiresIn: '60s',
    jwtRefreshTokenExpiresIn: '30d',
    cookieMaxAge: 24 * 60 * 60 * 1000,
    oauthSessionExpiresIn: 10 * 60 * 1000,
    authCodeExpiresIn: 10 * 60 * 1000,
    nodeEnv: 'development',
    apiPrefix: 'oidc',
    endpoints: {
        wellKnownAuthorizationServerMetadata: '/.well-known/oauth-authorization-server',
        register: '/reg',
        authorize: '/auth',
        callback: '/callback',
        token: '/token',
        validate: '/introspect',
        revoke: '/revoke',
    },
};
let McpOidcProviderModule = McpOidcProviderModule_1 = class McpOidcProviderModule {
    static forRoot(options) {
        const resolvedOptions = this.mergeAndValidateOptions(exports.DEFAULT_OIDC_OPTIONS, options);
        const oauthModuleOptions = {
            provide: 'OAUTH_MODULE_OPTIONS',
            useValue: resolvedOptions,
        };
        const imports = [
            config_1.ConfigModule,
            passport_1.PassportModule.register({
                defaultStrategy: 'jwt',
                session: false,
            }),
            jwt_1.JwtModule.register({
                secret: resolvedOptions.jwtSecret,
                signOptions: {
                    issuer: resolvedOptions.jwtIssuer,
                    audience: resolvedOptions.jwtAudience,
                },
            }),
            nest_oidc_provider_1.OidcModule.forRootAsync({
                useFactory: async () => ({
                    issuer: resolvedOptions.serverUrl,
                    path: `/${resolvedOptions.apiPrefix}`,
                    oidc: {
                        clients: [
                            {
                                client_id: 'mcp-client',
                                client_secret: 'mcp-client-secret',
                                redirect_uris: ['http://localhost:3000/callback'],
                                grant_types: ['authorization_code', 'refresh_token'],
                                response_types: ['code'],
                                token_endpoint_auth_method: 'client_secret_basic',
                                scope: 'openid profile email offline_access',
                            },
                        ],
                        pkce: {
                            methods: ['S256', 'plain'],
                            required: () => false,
                        },
                        features: {
                            devInteractions: { enabled: false },
                            deviceFlow: { enabled: false },
                            introspection: { enabled: true },
                            revocation: { enabled: true },
                            registration: { enabled: true },
                            userinfo: { enabled: true },
                        },
                        ttl: {
                            AccessToken: 3600,
                            AuthorizationCode: 600,
                            IdToken: 3600,
                            RefreshToken: 1209600,
                            Grant: 1209600,
                        },
                        scopes: ['openid', 'profile', 'email', 'offline_access'],
                        responseTypes: ['code', 'id_token', 'code id_token'],
                        grantTypes: ['authorization_code', 'refresh_token'],
                        subjectTypes: ['public'],
                        tokenEndpointAuthMethods: [
                            'client_secret_basic',
                            'client_secret_post',
                            'none',
                        ],
                        adapter: oidc_adapter_1.OidcMemoryAdapter.create,
                        findAccount: github_adapter_1.GitHubAdapter.findAccount,
                        interactions: {
                            url: async (_ctx, interaction) => {
                                if (interaction.prompt.name === 'login') {
                                    return `/oidc/interaction/${interaction.uid}`;
                                }
                                if (interaction.prompt.name === 'consent') {
                                    return `/oidc/interaction/${interaction.uid}`;
                                }
                                return `/oidc/interaction/${interaction.uid}`;
                            },
                        },
                        claims: {
                            openid: ['sub'],
                            profile: [
                                'name',
                                'family_name',
                                'given_name',
                                'preferred_username',
                            ],
                            email: ['email', 'email_verified'],
                        },
                        renderError: async (ctx, _out, error) => {
                            ctx.type = 'html';
                            ctx.body = `
                <html>
                  <head><title>Authentication Error</title></head>
                  <body>
                    <h1>Authentication Error</h1>
                    <p>${error.error_description || error.message}</p>
                    <p><a href="/">Return to application</a></p>
                  </body>
                </html>
              `;
                        },
                    },
                }),
                inject: [],
            }),
        ];
        const storeConfig = resolvedOptions.storeConfiguration;
        const isTypeOrmStore = storeConfig?.type === 'typeorm';
        if (storeConfig && storeConfig.type === 'typeorm') {
            const typeormOptions = storeConfig.options;
            imports.push(typeorm_1.TypeOrmModule.forRoot({
                ...typeormOptions,
                entities: [
                    ...(typeormOptions.entities || []),
                    entities_1.OAuthClientEntity,
                    entities_1.AuthorizationCodeEntity,
                    entities_1.OAuthSessionEntity,
                ],
            }), typeorm_1.TypeOrmModule.forFeature([
                entities_1.OAuthClientEntity,
                entities_1.AuthorizationCodeEntity,
                entities_1.OAuthSessionEntity,
            ]));
        }
        const oauthStoreProvider = this.createStoreProvider(resolvedOptions.storeConfiguration);
        const oauthStoreAliasProvider = {
            provide: memory_store_service_1.MemoryStore,
            useExisting: 'IOAuthStore',
        };
        const providers = [
            oauthModuleOptions,
            oauthStoreProvider,
            oauthStoreAliasProvider,
            oauth_strategy_service_1.OAuthStrategyService,
            client_service_1.ClientService,
            jwt_token_service_1.JwtTokenService,
            jwt_auth_guard_1.McpAuthJwtGuard,
            github_adapter_1.GitHubAdapter,
        ];
        if (isTypeOrmStore) {
            providers.push(typeorm_store_service_1.TypeOrmStore);
        }
        return {
            module: McpOidcProviderModule_1,
            imports,
            controllers: [oidc_provider_controller_1.OidcProviderController, resource_metadata_controller_1.ResourceMetadataController, well_known_controller_1.WellKnownController],
            providers,
            exports: [
                jwt_token_service_1.JwtTokenService,
                'IOAuthStore',
                memory_store_service_1.MemoryStore,
                jwt_auth_guard_1.McpAuthJwtGuard,
                oauth_strategy_service_1.OAuthStrategyService,
                github_adapter_1.GitHubAdapter,
            ],
        };
    }
    static mergeAndValidateOptions(defaults, options) {
        this.validateRequiredOptions(options);
        const resolvedOptions = {
            ...defaults,
            ...options,
            jwtIssuer: options.jwtIssuer ||
                options.serverUrl ||
                exports.DEFAULT_OIDC_OPTIONS.jwtIssuer,
            cookieSecure: options.cookieSecure || process.env.NODE_ENV === 'production',
        };
        this.validateResolvedOptions(resolvedOptions);
        return resolvedOptions;
    }
    static validateRequiredOptions(options) {
        const requiredFields = [
            'provider',
            'clientId',
            'clientSecret',
            'jwtSecret',
        ];
        for (const field of requiredFields) {
            if (!options[field]) {
                throw new Error(`OidcProviderOptions: ${String(field)} is required and must be provided by the user`);
            }
        }
    }
    static validateResolvedOptions(options) {
        if (options.jwtSecret.length < 32) {
            throw new Error('OidcProviderOptions: jwtSecret must be at least 32 characters long');
        }
        try {
            new URL(options.serverUrl);
            new URL(options.jwtIssuer);
        }
        catch (error) {
            throw new Error('OidcProviderOptions: serverUrl and jwtIssuer must be valid URLs');
        }
        if (!options.provider.name || !options.provider.strategy) {
            throw new Error('OidcProviderOptions: provider must have name and strategy');
        }
    }
    static createStoreProvider(storeConfiguration) {
        if (!storeConfiguration || storeConfiguration.type === 'memory') {
            return {
                provide: 'IOAuthStore',
                useValue: new memory_store_service_1.MemoryStore(),
            };
        }
        if (storeConfiguration.type === 'typeorm') {
            return {
                provide: 'IOAuthStore',
                useClass: typeorm_store_service_1.TypeOrmStore,
            };
        }
        if (storeConfiguration.type === 'custom') {
            return {
                provide: 'IOAuthStore',
                useValue: storeConfiguration.store,
            };
        }
        throw new Error(`Unknown store configuration type: ${storeConfiguration.type}`);
    }
};
exports.McpOidcProviderModule = McpOidcProviderModule;
exports.McpOidcProviderModule = McpOidcProviderModule = McpOidcProviderModule_1 = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({})
], McpOidcProviderModule);
//# sourceMappingURL=oidc-provider.module.js.map