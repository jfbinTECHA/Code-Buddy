{"version":3,"file":"client.service.js","sourceRoot":"","sources":["../../../src/authz/services/client.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { BadRequestException, Injectable, Inject } from '@nestjs/common';\nimport {\n  ClientRegistrationDto,\n  IOAuthStore,\n  OAuthClient,\n} from '../stores/oauth-store.interface';\nimport { randomBytes } from 'crypto';\nimport { OAuthModuleOptions } from '../providers/oauth-provider.interface';\n\n@Injectable()\nexport class ClientService {\n  constructor(\n    @Inject('IOAuthStore') private readonly store: IOAuthStore,\n    @Inject('OAUTH_MODULE_OPTIONS')\n    private readonly options: OAuthModuleOptions,\n  ) {}\n\n  /**\n   * Register a client application.\n   * Always creates a new client record. client_name is not treated as unique.\n   *\n   * Note: Left open for future enhancements (e.g., software statements,\n   * URL-based Client ID Metadata Documents) via preRegistrationChecks().\n   */\n  async registerClient(\n    registrationDto: ClientRegistrationDto,\n  ): Promise<OAuthClient> {\n    // Validate required fields\n    if (\n      !registrationDto.redirect_uris ||\n      !Array.isArray(registrationDto.redirect_uris)\n    ) {\n      throw new BadRequestException(\n        'redirect_uris is required and must be an array',\n      );\n    }\n\n    // Validate token_endpoint_auth_method if provided\n    const supportedAuthMethods = [\n      'client_secret_basic',\n      'client_secret_post',\n      'none',\n    ];\n    if (\n      registrationDto.token_endpoint_auth_method &&\n      !supportedAuthMethods.includes(registrationDto.token_endpoint_auth_method)\n    ) {\n      throw new BadRequestException(\n        `Unsupported token_endpoint_auth_method. Supported methods: ${supportedAuthMethods.join(', ')}`,\n      );\n    }\n\n    // Default values for new clients\n    const defaultClientValues = {\n      grant_types: ['authorization_code', 'refresh_token'],\n      response_types: ['code'],\n      token_endpoint_auth_method:\n        registrationDto.token_endpoint_auth_method || 'none',\n    };\n\n    // Future-proofing: hook for software statements / metadata URL validations\n    await this.preRegistrationChecks(registrationDto);\n\n    const now = new Date();\n\n    // Create new client - merge defaults with registration data\n    const client_id = this.store.generateClientId(\n      registrationDto as OAuthClient,\n    );\n\n    // Only generate client_secret for methods that require it\n    const authMethod = registrationDto.token_endpoint_auth_method || 'none';\n    const client_secret =\n      authMethod !== 'none' ? randomBytes(32).toString('hex') : undefined;\n\n    const newClient: OAuthClient = {\n      ...defaultClientValues,\n      ...registrationDto,\n      client_id,\n      client_secret,\n      created_at: now,\n      updated_at: now,\n    };\n    const client = await this.store.storeClient(newClient);\n    const filteredClient = Object.fromEntries(\n      Object.entries(client).filter(([, value]) => value !== null),\n    ) as OAuthClient;\n\n    return filteredClient;\n  }\n\n  /**\n   * Hook for future registration policies (e.g., software statements per RFC 7591/7592,\n   * or URL-based Client Registration using Client ID Metadata Documents).\n   * Currently a no-op to keep behavior: always create a new client.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected async preRegistrationChecks(\n    _dto: ClientRegistrationDto,\n  ): Promise<void> {\n    // Intentionally left blank. Implement validations/attestations in the future.\n  }\n\n  async getClient(clientId: string): Promise<OAuthClient | null> {\n    const client = await this.store.getClient(clientId);\n    if (!client) {\n      return null;\n    }\n\n    // Remove null fields from the client object\n    const filteredClient = Object.fromEntries(\n      Object.entries(client).filter(([, value]) => value !== null),\n    ) as OAuthClient;\n\n    return filteredClient;\n  }\n\n  async validateRedirectUri(\n    clientId: string,\n    redirectUri: string,\n  ): Promise<boolean> {\n    const client = await this.getClient(clientId);\n    return client ? client.redirect_uris.includes(redirectUri) : false;\n  }\n}\n"]}