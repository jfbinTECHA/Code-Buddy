"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var GitHubAdapter_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitHubAdapter = void 0;
const common_1 = require("@nestjs/common");
let GitHubAdapter = GitHubAdapter_1 = class GitHubAdapter {
    constructor(store, options) {
        this.store = store;
        this.options = options;
        this.logger = new common_1.Logger(GitHubAdapter_1.name);
    }
    static create(name) {
        return class OidcAdapterInstance {
            constructor(name) {
                this.name = name;
                this.logger = new common_1.Logger(`OidcAdapter:${name}`);
            }
            async find(id) {
                this.logger.debug(`Finding ${this.name} with id: ${id}`);
                try {
                    switch (this.name) {
                        case 'Client':
                            const client = await this.findClient(id);
                            return client ? this.formatClientForOidc(client) : null;
                        case 'Session':
                            return await this.findSession(id);
                        case 'AccessToken':
                        case 'RefreshToken':
                        case 'AuthorizationCode':
                        case 'IdToken':
                            return await this.findToken(id);
                        case 'Grant':
                            return await this.findGrant(id);
                        default:
                            this.logger.warn(`Unknown adapter type: ${this.name}`);
                            return null;
                    }
                }
                catch (error) {
                    this.logger.error(`Error finding ${this.name}:`, error);
                    return null;
                }
            }
            async findClient(clientId) {
                return {
                    client_id: clientId,
                    client_secret: 'dummy_secret',
                    redirect_uris: ['http://localhost:3000/callback'],
                    grant_types: ['authorization_code', 'refresh_token'],
                    response_types: ['code'],
                    token_endpoint_auth_method: 'client_secret_basic',
                };
            }
            async findSession(sessionId) {
                return null;
            }
            async findToken(tokenId) {
                return null;
            }
            async findGrant(grantId) {
                return null;
            }
            formatClientForOidc(client) {
                return {
                    client_id: client.client_id,
                    client_secret: client.client_secret,
                    redirect_uris: client.redirect_uris || [],
                    grant_types: client.grant_types || ['authorization_code'],
                    response_types: client.response_types || ['code'],
                    token_endpoint_auth_method: client.token_endpoint_auth_method || 'client_secret_basic',
                    scope: client.scope || 'openid profile email',
                };
            }
            async findByUserCode(userCode) {
                this.logger.debug(`Finding ${this.name} by user code: ${userCode}`);
                return null;
            }
            async findByDeviceInfo(deviceInfo) {
                this.logger.debug(`Finding ${this.name} by device info`);
                return null;
            }
            async upsert(id, payload, expiresIn) {
                this.logger.debug(`Upserting ${this.name} with id: ${id}`);
                try {
                    const expiresAt = expiresIn
                        ? Date.now() + expiresIn * 1000
                        : undefined;
                    switch (this.name) {
                        case 'Client':
                            await this.upsertClient(id, payload);
                            break;
                        case 'Session':
                            await this.upsertSession(id, payload, expiresAt);
                            break;
                        case 'AccessToken':
                        case 'RefreshToken':
                        case 'AuthorizationCode':
                        case 'IdToken':
                            await this.upsertToken(id, payload, expiresAt);
                            break;
                        case 'Grant':
                            await this.upsertGrant(id, payload, expiresAt);
                            break;
                        default:
                            this.logger.warn(`Unknown adapter type for upsert: ${this.name}`);
                    }
                }
                catch (error) {
                    this.logger.error(`Error upserting ${this.name}:`, error);
                    throw error;
                }
            }
            async upsertClient(clientId, payload) {
                this.logger.debug(`Client upsert: ${clientId}`, payload);
            }
            async upsertSession(sessionId, payload, expiresAt) {
                this.logger.debug(`Session upsert: ${sessionId}`);
            }
            async upsertToken(tokenId, payload, expiresAt) {
                this.logger.debug(`Token upsert: ${tokenId}, expires: ${expiresAt}`);
            }
            async upsertGrant(grantId, payload, expiresAt) {
                this.logger.debug(`Grant upsert: ${grantId}`);
            }
            async destroy(id) {
                this.logger.debug(`Destroying ${this.name} with id: ${id}`);
                try {
                    switch (this.name) {
                        case 'Client':
                            await this.destroyClient(id);
                            break;
                        case 'Session':
                            await this.destroySession(id);
                            break;
                        case 'AccessToken':
                        case 'RefreshToken':
                        case 'AuthorizationCode':
                        case 'IdToken':
                            await this.destroyToken(id);
                            break;
                        case 'Grant':
                            await this.destroyGrant(id);
                            break;
                        default:
                            this.logger.warn(`Unknown adapter type for destroy: ${this.name}`);
                    }
                }
                catch (error) {
                    this.logger.error(`Error destroying ${this.name}:`, error);
                    throw error;
                }
            }
            async destroyClient(clientId) {
                this.logger.debug(`Client destroy: ${clientId}`);
            }
            async destroySession(sessionId) {
                this.logger.debug(`Session destroy: ${sessionId}`);
            }
            async destroyToken(tokenId) {
                this.logger.debug(`Token destroy: ${tokenId}`);
            }
            async destroyGrant(grantId) {
                this.logger.debug(`Grant destroy: ${grantId}`);
            }
            async revokeByGrantId(grantId) {
                this.logger.debug(`Revoking ${this.name} by grant id: ${grantId}`);
            }
            async consume(id) {
                this.logger.debug(`Consuming ${this.name} with id: ${id}`);
            }
        };
    }
    static async findAccount(ctx, id) {
        const logger = new common_1.Logger('GitHubAdapter:findAccount');
        logger.debug(`Finding account: ${id}`);
        return {
            accountId: id,
            async claims(use, scope) {
                logger.debug(`Getting claims for account ${id}, use: ${use}, scope: ${scope}`);
                const claims = {
                    sub: id,
                };
                if (scope.includes('profile')) {
                    claims.preferred_username = id;
                }
                if (scope.includes('email')) {
                }
                return claims;
            },
        };
    }
};
exports.GitHubAdapter = GitHubAdapter;
exports.GitHubAdapter = GitHubAdapter = GitHubAdapter_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, common_1.Inject)('IOAuthStore')),
    __param(1, (0, common_1.Inject)('OAUTH_MODULE_OPTIONS')),
    __metadata("design:paramtypes", [Object, Object])
], GitHubAdapter);
//# sourceMappingURL=github.adapter.js.map