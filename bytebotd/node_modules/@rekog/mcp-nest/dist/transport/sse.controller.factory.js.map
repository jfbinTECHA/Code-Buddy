{"version":3,"file":"sse.controller.factory.js","sourceRoot":"","sources":["../../src/transport/sse.controller.factory.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Body,\n  CanActivate,\n  Controller,\n  Get,\n  Inject,\n  Logger,\n  OnModuleInit,\n  Post,\n  Req,\n  Res,\n  Type,\n  UseGuards,\n  VERSION_NEUTRAL,\n  applyDecorators,\n} from '@nestjs/common';\nimport { ApplicationConfig, ContextIdFactory, ModuleRef } from '@nestjs/core';\nimport type { Request, Response } from 'express';\n\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';\nimport { buildMcpCapabilities } from '../utils/capabilities-builder';\nimport { McpOptions } from '../interfaces';\nimport { McpExecutorService } from '../services/mcp-executor.service';\nimport { McpRegistryService } from '../services/mcp-registry.service';\nimport { SsePingService } from '../services/sse-ping.service';\nimport { normalizeEndpoint } from '../utils/normalize-endpoint';\n\n/**\n * Creates a controller for handling SSE connections and tool executions\n */\nexport function createSseController(\n  sseEndpoint: string,\n  messagesEndpoint: string,\n  guards: Type<CanActivate>[] = [],\n  decorators: ClassDecorator[] = [],\n) {\n  @Controller({\n    version: VERSION_NEUTRAL,\n  })\n  @applyDecorators(...decorators)\n  class SseController implements OnModuleInit {\n    readonly logger = new Logger(SseController.name);\n    // Note: Currently, storing transports and servers in memory makes this not viable for scaling out.\n    // Redis can be used for this purpose, but considering that HTTP Streamable succeeds SSE then we can drop keeping this in memory.\n\n    // Map to store active transports by session ID\n    public transports = new Map<string, SSEServerTransport>();\n    // Map to store MCP server instances by session ID\n    public mcpServers = new Map<string, McpServer>();\n\n    constructor(\n      @Inject('MCP_OPTIONS') public readonly options: McpOptions,\n      @Inject('MCP_MODULE_ID') public readonly mcpModuleId: string,\n      public readonly applicationConfig: ApplicationConfig,\n      public readonly moduleRef: ModuleRef,\n      public readonly toolRegistry: McpRegistryService,\n      @Inject(SsePingService) public readonly pingService: SsePingService,\n    ) {}\n\n    /**\n     * Initialize the controller and configure ping service\n     */\n    onModuleInit() {\n      // Configure ping service with options\n      this.pingService.configure({\n        pingEnabled: this.options.sse?.pingEnabled, // Enable by default\n        pingIntervalMs: this.options.sse?.pingIntervalMs,\n      });\n    }\n\n    /**\n     * SSE connection endpoint\n     */\n    @Get(sseEndpoint)\n    @UseGuards(...guards)\n    async sse(@Res() res: Response) {\n      const transport = new SSEServerTransport(\n        normalizeEndpoint(\n          `${this.applicationConfig.getGlobalPrefix()}/${messagesEndpoint}`,\n        ),\n        res,\n      );\n      const sessionId = transport.sessionId;\n\n      // Create a new MCP server instance with dynamic capabilities\n      const capabilities = buildMcpCapabilities(\n        this.mcpModuleId,\n        this.toolRegistry,\n        this.options,\n      );\n      this.logger.debug('Built MCP capabilities:', capabilities);\n\n      // Create a new MCP server for this session with dynamic capabilities\n      const mcpServer = new McpServer(\n        { name: this.options.name, version: this.options.version },\n        {\n          capabilities,\n          instructions: this.options.instructions || '',\n        },\n      );\n\n      // Store the transport and server for this session\n      this.transports.set(sessionId, transport);\n      this.mcpServers.set(sessionId, mcpServer);\n\n      // Register the connection with the ping service\n      this.pingService.registerConnection(sessionId, transport, res);\n\n      transport.onclose = () => {\n        // Clean up when the connection closes\n        this.transports.delete(sessionId);\n        this.mcpServers.delete(sessionId);\n        this.pingService.removeConnection(sessionId);\n      };\n\n      await mcpServer.connect(transport);\n    }\n\n    /**\n     * Tool execution endpoint - protected by the provided guards\n     */\n    @Post(messagesEndpoint)\n    @UseGuards(...guards)\n    async messages(\n      @Req() req: Request,\n      @Res() res: Response,\n      @Body() body: unknown,\n    ) {\n      const sessionId = req.query.sessionId as string;\n      const transport = this.transports.get(sessionId);\n\n      if (!transport) {\n        return res.status(404).send('Session not found');\n      }\n\n      const mcpServer = this.mcpServers.get(sessionId);\n      if (!mcpServer) {\n        return res.status(404).send('MCP server not found for session');\n      }\n\n      // Resolve the request-scoped tool executor service\n      const contextId = ContextIdFactory.getByRequest(req);\n      const executor = await this.moduleRef.resolve(\n        McpExecutorService,\n        contextId,\n      );\n\n      // Register request handlers with the user context from this specific request\n      executor.registerRequestHandlers(mcpServer, req);\n\n      // Process the message\n      await transport.handlePostMessage(req, res, body);\n    }\n  }\n\n  return SseController;\n}\n"]}