{"version":3,"file":"mcp.module.js","sourceRoot":"","sources":["../src/mcp.module.ts"],"names":[],"mappings":"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","sourcesContent":["import { DynamicModule, Module, Provider, Type } from '@nestjs/common';\nimport { DiscoveryModule } from '@nestjs/core';\nimport { McpOptions, McpTransportType } from './interfaces';\nimport { McpExecutorService } from './services/mcp-executor.service';\nimport { McpRegistryService } from './services/mcp-registry.service';\nimport { SsePingService } from './services/sse-ping.service';\nimport { createSseController } from './transport/sse.controller.factory';\nimport { StdioService } from './transport/stdio.service';\nimport { createStreamableHttpController } from './transport/streamable-http.controller.factory';\nimport { normalizeEndpoint } from './utils/normalize-endpoint';\n\nlet instanceIdCounter = 0;\n\n@Module({\n  imports: [DiscoveryModule],\n  providers: [McpRegistryService, McpExecutorService],\n})\nexport class McpModule {\n  /**\n   * To avoid import circular dependency issues, we use a marker property.\n   */\n  readonly __isMcpModule = true;\n\n  static forRoot(options: McpOptions): DynamicModule {\n    const defaultOptions: Partial<McpOptions> = {\n      transport: [\n        McpTransportType.SSE,\n        McpTransportType.STREAMABLE_HTTP,\n        McpTransportType.STDIO,\n      ],\n      sseEndpoint: 'sse',\n      messagesEndpoint: 'messages',\n      mcpEndpoint: 'mcp',\n      guards: [],\n      decorators: [],\n      streamableHttp: {\n        enableJsonResponse: true,\n        sessionIdGenerator: undefined,\n        statelessMode: true,\n      },\n      sse: {\n        pingEnabled: true,\n        pingIntervalMs: 30000,\n      },\n    };\n    const mergedOptions = { ...defaultOptions, ...options } as McpOptions;\n    mergedOptions.sseEndpoint = normalizeEndpoint(mergedOptions.sseEndpoint);\n    mergedOptions.messagesEndpoint = normalizeEndpoint(\n      mergedOptions.messagesEndpoint,\n    );\n    mergedOptions.mcpEndpoint = normalizeEndpoint(mergedOptions.mcpEndpoint);\n\n    const moduleId = `mcp-module-${instanceIdCounter++}`;\n    const providers = this.createProvidersFromOptions(mergedOptions, moduleId);\n    const controllers = this.createControllersFromOptions(mergedOptions);\n\n    return {\n      module: McpModule,\n      controllers,\n      providers,\n      exports: [McpRegistryService],\n    };\n  }\n\n  private static createControllersFromOptions(\n    options: McpOptions,\n  ): Type<any>[] {\n    const sseEndpoint = options.sseEndpoint ?? 'sse';\n    const messagesEndpoint = options.messagesEndpoint ?? 'messages';\n    const mcpEndpoint = options.mcpEndpoint ?? 'mcp';\n    const guards = options.guards ?? [];\n    const transports = Array.isArray(options.transport)\n      ? options.transport\n      : [options.transport ?? McpTransportType.SSE];\n    const controllers: Type<any>[] = [];\n    const decorators = options.decorators ?? [];\n\n    if (transports.includes(McpTransportType.SSE)) {\n      const sseController = createSseController(\n        sseEndpoint,\n        messagesEndpoint,\n        guards,\n        decorators,\n      );\n      controllers.push(sseController);\n    }\n\n    if (transports.includes(McpTransportType.STREAMABLE_HTTP)) {\n      const streamableHttpController = createStreamableHttpController(\n        mcpEndpoint,\n        guards,\n        decorators,\n      );\n      controllers.push(streamableHttpController);\n    }\n\n    if (transports.includes(McpTransportType.STDIO)) {\n      // STDIO transport is handled by injectable StdioService, no controller\n    }\n\n    return controllers;\n  }\n\n  private static createProvidersFromOptions(\n    options: McpOptions,\n    moduleId: string,\n  ): Provider[] {\n    const providers: Provider[] = [\n      {\n        provide: 'MCP_OPTIONS',\n        useValue: options,\n      },\n      {\n        provide: 'MCP_MODULE_ID',\n        useValue: moduleId,\n      },\n      McpRegistryService,\n      McpExecutorService,\n    ];\n\n    const transports = Array.isArray(options.transport)\n      ? options.transport\n      : [options.transport ?? McpTransportType.SSE];\n\n    if (transports.includes(McpTransportType.SSE)) {\n      providers.push(SsePingService);\n    }\n\n    if (transports.includes(McpTransportType.STDIO)) {\n      providers.push(StdioService);\n    }\n\n    return providers;\n  }\n}\n"]}