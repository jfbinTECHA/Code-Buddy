"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@nestjs/common");
const testing_1 = require("@nestjs/testing");
const mcp_registry_service_1 = require("./mcp-registry.service");
const core_1 = require("@nestjs/core");
const tool_decorator_1 = require("../decorators/tool.decorator");
const mcp_module_1 = require("../mcp.module");
describe('McpRegistryService', () => {
    let service;
    const mockMcpModuleId = 'test-mcp-module-id';
    const mockResource = (name, uri) => ({
        type: 'resource',
        metadata: { name, uri },
        providerClass: Symbol(name),
        methodName: 'someMethod',
    });
    beforeEach(async () => {
        const module = await testing_1.Test.createTestingModule({
            providers: [
                mcp_registry_service_1.McpRegistryService,
                {
                    provide: core_1.DiscoveryService,
                    useValue: {
                        getProviders: jest.fn(() => []),
                        getControllers: jest.fn(() => []),
                    },
                },
                core_1.MetadataScanner,
            ],
        }).compile();
        service = module.get(mcp_registry_service_1.McpRegistryService);
        const mockResources = [
            mockResource('res0', '/posts/comments'),
            mockResource('res1', '/users/{id}'),
            mockResource('res2', '/posts/:postId/comments'),
            mockResource('res3', 'mcp://hello-world'),
        ];
        service.discoveredToolsByMcpModuleId = new Map([
            [mockMcpModuleId, mockResources],
        ]);
    });
    it('should return the correct resource by URI', () => {
        const result = service.findResourceByUri(mockMcpModuleId, '/users/123');
        expect(result?.resource.metadata.name).toBe('res1');
        expect(result?.params).toEqual({ id: '123' });
    });
    it('should return the correct resource by URI', () => {
        const result = service.findResourceByUri(mockMcpModuleId, '/users/123');
        expect(result?.resource.metadata.name).toBe('res1');
        expect(result?.params).toEqual({ id: '123' });
    });
    it('should return undefined for unknown URI', () => {
        const result = service.findResourceByUri(mockMcpModuleId, '/unknown/path');
        expect(result).toBeUndefined();
    });
    it('should match complex URI template', () => {
        const result = service.findResourceByUri(mockMcpModuleId, '/posts/456/comments');
        expect(result?.resource.metadata.name).toBe('res2');
        expect(result?.params).toEqual({ postId: '456' });
    });
    it('should match simple URI template', () => {
        const result = service.findResourceByUri(mockMcpModuleId, '/posts/comments');
        expect(result?.resource.metadata.name).toBe('res0');
        expect(result?.params).toEqual({});
    });
    it('should match mcp URI', () => {
        const result = service.findResourceByUri(mockMcpModuleId, 'mcp://hello-world');
        expect(result?.resource.metadata.name).toBe('res3');
        expect(result?.params).toEqual({});
    });
});
describe('McpRegistryService - Multiple discovery roots', () => {
    const mcpModuleA = mcp_module_1.McpModule.forRoot({ name: 'server-a', version: '0.0.1' });
    const mcpModuleB = mcp_module_1.McpModule.forRoot({ name: 'server-b', version: '0.0.1' });
    let ToolsA = class ToolsA {
        toolA() {
            return 'Tool A result';
        }
    };
    __decorate([
        (0, tool_decorator_1.Tool)({
            name: 'toolA',
            description: 'Tool A from ModuleA',
        }),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], ToolsA.prototype, "toolA", null);
    ToolsA = __decorate([
        (0, common_1.Injectable)()
    ], ToolsA);
    let ToolsB = class ToolsB {
        toolB() {
            return 'Tool B result';
        }
    };
    __decorate([
        (0, tool_decorator_1.Tool)({
            name: 'toolB',
            description: 'Tool B from ModuleB',
        }),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], ToolsB.prototype, "toolB", null);
    ToolsB = __decorate([
        (0, common_1.Injectable)()
    ], ToolsB);
    let ModuleA = class ModuleA {
    };
    ModuleA = __decorate([
        (0, common_1.Module)({
            imports: [mcpModuleA],
            providers: [ToolsA],
            exports: [ToolsA],
        })
    ], ModuleA);
    let ModuleB = class ModuleB {
    };
    ModuleB = __decorate([
        (0, common_1.Module)({
            imports: [mcpModuleB],
            providers: [ToolsB],
            exports: [ToolsB],
        })
    ], ModuleB);
    let service;
    const idModuleA = getMcpModuleId(mcpModuleA);
    const idModuleB = getMcpModuleId(mcpModuleB);
    beforeAll(async () => {
        const module = await testing_1.Test.createTestingModule({
            imports: [ModuleA, ModuleB],
        }).compile();
        service = module.get(mcp_registry_service_1.McpRegistryService);
        service.onApplicationBootstrap();
    });
    it('server-a discovered toolA only', () => {
        const tools = service.getTools(idModuleA);
        expect(tools.length).toBe(1);
        const tool = tools.find((tool) => tool.metadata.name === 'toolA');
        expect(tool).toBeDefined();
    });
    it('server-b discovered toolB only', () => {
        const tools = service.getTools(idModuleB);
        expect(tools.length).toBe(1);
        const tool = tools.find((tool) => tool.metadata.name === 'toolB');
        expect(tool).toBeDefined();
    });
});
describe('McpRegistryService - Single discovery root with multiple MCP servers', () => {
    const mcpModuleA = mcp_module_1.McpModule.forRoot({ name: 'server-a', version: '0.0.1' });
    const mcpModuleB = mcp_module_1.McpModule.forRoot({ name: 'server-b', version: '0.0.1' });
    const idModuleA = getMcpModuleId(mcpModuleA);
    const idModuleB = getMcpModuleId(mcpModuleB);
    let Tools = class Tools {
        tool() {
            return 'Tool result';
        }
    };
    __decorate([
        (0, tool_decorator_1.Tool)({
            name: 'tool',
            description: 'Tool from AppModule',
        }),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Tools.prototype, "tool", null);
    Tools = __decorate([
        (0, common_1.Injectable)()
    ], Tools);
    let AppModule = class AppModule {
    };
    AppModule = __decorate([
        (0, common_1.Module)({
            imports: [mcpModuleA, mcpModuleB],
            providers: [Tools],
        })
    ], AppModule);
    let service;
    beforeAll(async () => {
        const module = await testing_1.Test.createTestingModule({
            imports: [AppModule],
        }).compile();
        service = module.get(mcp_registry_service_1.McpRegistryService);
        service.onApplicationBootstrap();
    });
    it('server-a discovered the tool', () => {
        const tools = service.getTools(idModuleA);
        expect(tools.length).toBe(1);
        const tool = tools.find((tool) => tool.metadata.name === 'tool');
        expect(tool).toBeDefined();
    });
    it('server-b discovered the tool', () => {
        const tools = service.getTools(idModuleB);
        expect(tools.length).toBe(1);
        const tool = tools.find((tool) => tool.metadata.name === 'tool');
        expect(tool).toBeDefined();
    });
});
function getMcpModuleId(module) {
    const valueProvider = module?.providers?.find((provider) => typeof provider === 'object' &&
        provider.provide === 'MCP_MODULE_ID');
    if (!valueProvider) {
        throw new Error('MCP_MODULE_ID provider not found in module. This should not happen.');
    }
    return valueProvider.useValue;
}
//# sourceMappingURL=mcp-registry.service.spec.js.map