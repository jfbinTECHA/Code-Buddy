{"version":3,"file":"mcp.module.js","sourceRoot":"","sources":["../../src/mcp/mcp.module.ts"],"names":[],"mappings":"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","sourcesContent":["import { DynamicModule, Module, Provider, Type } from '@nestjs/common';\nimport { DiscoveryModule } from '@nestjs/core';\nimport { McpTransportType } from './interfaces';\nimport type {\n  McpOptions,\n  McpModuleAsyncOptions,\n  McpOptionsFactory,\n  McpAsyncOptions,\n} from './interfaces';\nimport { McpExecutorService } from './services/mcp-executor.service';\nimport { McpRegistryService } from './services/mcp-registry.service';\nimport { McpSseService } from './services/mcp-sse.service';\nimport { McpStreamableHttpService } from './services/mcp-streamable-http.service';\nimport { SsePingService } from './services/sse-ping.service';\nimport { createSseController } from './transport/sse.controller.factory';\nimport { StdioService } from './transport/stdio.service';\nimport { createStreamableHttpController } from './transport/streamable-http.controller.factory';\nimport { normalizeEndpoint } from './utils/normalize-endpoint';\n\nlet instanceIdCounter = 0;\n\n@Module({\n  imports: [DiscoveryModule],\n  providers: [McpRegistryService, McpExecutorService],\n})\nexport class McpModule {\n  /**\n   * To avoid import circular dependency issues, we use a marker property.\n   */\n  readonly __isMcpModule = true;\n\n  static forRoot(options: McpOptions): DynamicModule {\n    const defaultOptions: Partial<McpOptions> = {\n      transport: [\n        McpTransportType.SSE,\n        McpTransportType.STREAMABLE_HTTP,\n        McpTransportType.STDIO,\n      ],\n      sseEndpoint: 'sse',\n      messagesEndpoint: 'messages',\n      mcpEndpoint: 'mcp',\n      guards: [],\n      decorators: [],\n      streamableHttp: {\n        enableJsonResponse: true,\n        sessionIdGenerator: undefined,\n        statelessMode: true,\n      },\n      sse: {\n        pingEnabled: true,\n        pingIntervalMs: 30000,\n      },\n    };\n    const mergedOptions = { ...defaultOptions, ...options } as McpOptions;\n    mergedOptions.sseEndpoint = normalizeEndpoint(mergedOptions.sseEndpoint);\n    mergedOptions.messagesEndpoint = normalizeEndpoint(\n      mergedOptions.messagesEndpoint,\n    );\n    mergedOptions.mcpEndpoint = normalizeEndpoint(mergedOptions.mcpEndpoint);\n\n    const moduleId = `mcp-module-${instanceIdCounter++}`;\n    const providers = this.createProvidersFromOptions(mergedOptions, moduleId);\n    const controllers = this.createControllersFromOptions(mergedOptions);\n    return {\n      module: McpModule,\n      controllers,\n      providers,\n      exports: [McpRegistryService, McpSseService, McpStreamableHttpService],\n    };\n  }\n\n  /**\n   * Asynchronous variant of forRoot. Controllers are NOT auto-registered here because\n   * they must be declared synchronously at module definition time. This keeps the\n   * API explicit: when using forRootAsync, you are responsible for creating and\n   * registering any transport controllers (e.g. via createSseController / createStreamableHttpController).\n   *\n   * The exposed async options intentionally omit the `transport` property. Transport\n   * selection only influences automatic controller creation (which does not occur here)\n   * and STDIO auto-start. If you need STDIO with forRootAsync, manually instantiate\n   * and bootstrap it (e.g. by importing a module that injects StdioService) or add\n   * an explicit provider that sets options.transport before use.\n   */\n  static forRootAsync(options: McpModuleAsyncOptions): DynamicModule {\n    const moduleId = `mcp-module-${instanceIdCounter++}`;\n    const asyncProviders = this.createAsyncProviders(options);\n    const baseProviders: Provider[] = [\n      {\n        provide: 'MCP_MODULE_ID',\n        useValue: moduleId,\n      },\n      McpRegistryService,\n      McpExecutorService,\n      SsePingService,\n      McpSseService,\n      McpStreamableHttpService,\n      StdioService,\n    ];\n\n    return {\n      module: McpModule,\n      imports: options.imports ?? [],\n      // No automatic controllers in async mode\n      controllers: [],\n      providers: [\n        ...asyncProviders,\n        ...baseProviders,\n        ...(options.extraProviders ?? []),\n      ],\n      exports: [McpRegistryService, McpSseService, McpStreamableHttpService],\n    };\n  }\n\n  private static createAsyncProviders(\n    options: McpModuleAsyncOptions,\n  ): Provider[] {\n    if (options.useFactory) {\n      return [\n        {\n          provide: 'MCP_OPTIONS',\n          useFactory: async (...args: unknown[]) => {\n            const resolved: McpAsyncOptions = await options.useFactory!(\n              ...args,\n            );\n            return this.mergeAndNormalizeAsyncOptions(resolved);\n          },\n          inject: options.inject ?? [],\n        },\n      ];\n    }\n\n    // useClass / useExisting path\n    const inject: any[] = [];\n    let optionsFactoryProvider: Provider | undefined;\n\n    if (options.useExisting || options.useClass) {\n      const useExisting = options.useExisting || options.useClass!;\n      inject.push(useExisting);\n      if (options.useClass) {\n        optionsFactoryProvider = {\n          provide: options.useClass,\n          useClass: options.useClass,\n        } as Provider;\n      }\n\n      return [\n        ...(optionsFactoryProvider ? [optionsFactoryProvider] : []),\n        {\n          provide: 'MCP_OPTIONS',\n          useFactory: async (factory: McpOptionsFactory) => {\n            const resolved = await factory.createMcpOptions();\n            return this.mergeAndNormalizeAsyncOptions(resolved);\n          },\n          inject,\n        },\n      ];\n    }\n\n    throw new Error('Invalid McpModuleAsyncOptions configuration.');\n  }\n\n  private static mergeAndNormalizeAsyncOptions(\n    resolved: McpAsyncOptions,\n  ): McpOptions {\n    const defaultOptions: Partial<McpOptions> = {\n      sseEndpoint: 'sse',\n      messagesEndpoint: 'messages',\n      mcpEndpoint: 'mcp',\n      guards: [],\n      decorators: [],\n      streamableHttp: {\n        enableJsonResponse: true,\n        sessionIdGenerator: undefined,\n        statelessMode: true,\n      },\n      sse: {\n        pingEnabled: true,\n        pingIntervalMs: 30000,\n      },\n    };\n    // Note: transport intentionally omitted\n    const merged = { ...defaultOptions, ...resolved } as McpOptions;\n    merged.sseEndpoint = normalizeEndpoint(merged.sseEndpoint);\n    merged.messagesEndpoint = normalizeEndpoint(merged.messagesEndpoint);\n    merged.mcpEndpoint = normalizeEndpoint(merged.mcpEndpoint);\n    return merged;\n  }\n\n  private static createControllersFromOptions(\n    options: McpOptions,\n  ): Type<any>[] {\n    const sseEndpoint = options.sseEndpoint ?? 'sse';\n    const messagesEndpoint = options.messagesEndpoint ?? 'messages';\n    const mcpEndpoint = options.mcpEndpoint ?? 'mcp';\n    const guards = options.guards ?? [];\n    const transports = Array.isArray(options.transport)\n      ? options.transport\n      : [options.transport ?? McpTransportType.SSE];\n    const controllers: Type<any>[] = [];\n    const decorators = options.decorators ?? [];\n    const apiPrefix = options.apiPrefix ?? '';\n\n    if (transports.includes(McpTransportType.SSE)) {\n      const sseController = createSseController(\n        sseEndpoint,\n        messagesEndpoint,\n        apiPrefix,\n        guards,\n        decorators,\n      );\n      controllers.push(sseController);\n    }\n\n    if (transports.includes(McpTransportType.STREAMABLE_HTTP)) {\n      const streamableHttpController = createStreamableHttpController(\n        mcpEndpoint,\n        apiPrefix,\n        guards,\n        decorators,\n      );\n      controllers.push(streamableHttpController);\n    }\n\n    if (transports.includes(McpTransportType.STDIO)) {\n      // STDIO transport is handled by injectable StdioService, no controller\n    }\n\n    return controllers;\n  }\n\n  private static createProvidersFromOptions(\n    options: McpOptions,\n    moduleId: string,\n  ): Provider[] {\n    const providers: Provider[] = [\n      {\n        provide: 'MCP_OPTIONS',\n        useValue: options,\n      },\n      {\n        provide: 'MCP_MODULE_ID',\n        useValue: moduleId,\n      },\n      McpRegistryService,\n      McpExecutorService,\n      SsePingService,\n      McpSseService,\n      McpStreamableHttpService,\n      StdioService,\n    ];\n\n    return providers;\n  }\n}\n"]}