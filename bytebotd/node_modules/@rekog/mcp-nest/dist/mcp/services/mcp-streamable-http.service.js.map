{"version":3,"file":"mcp-streamable-http.service.js","sourceRoot":"","sources":["../../../src/mcp/services/mcp-streamable-http.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Inject, Injectable, Logger, OnModuleDestroy } from '@nestjs/common';\nimport { ContextIdFactory, ModuleRef } from '@nestjs/core';\nimport { randomUUID } from 'crypto';\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';\nimport { HttpAdapterFactory } from '../adapters/http-adapter.factory';\nimport {\n  HttpRequest,\n  HttpResponse,\n} from '../interfaces/http-adapter.interface';\nimport { McpOptions } from '../interfaces';\nimport { McpExecutorService } from './mcp-executor.service';\nimport { McpRegistryService } from './mcp-registry.service';\nimport { buildMcpCapabilities } from '../utils/capabilities-builder';\n\n@Injectable()\nexport class McpStreamableHttpService implements OnModuleDestroy {\n  private readonly logger = new Logger(McpStreamableHttpService.name);\n  private readonly transports: {\n    [sessionId: string]: StreamableHTTPServerTransport;\n  } = {};\n  private readonly mcpServers: { [sessionId: string]: McpServer } = {};\n  private readonly executors: { [sessionId: string]: McpExecutorService } = {};\n  private readonly isStatelessMode: boolean;\n\n  constructor(\n    @Inject('MCP_OPTIONS') private readonly options: McpOptions,\n    @Inject('MCP_MODULE_ID') private readonly mcpModuleId: string,\n    private readonly moduleRef: ModuleRef,\n    private readonly toolRegistry: McpRegistryService,\n  ) {\n    // Determine if we're in stateless mode\n    this.isStatelessMode = !!options.streamableHttp?.statelessMode;\n  }\n\n  /**\n   * Create a new MCP server instance for stateless requests\n   */\n  async createStatelessServer(rawReq: any): Promise<{\n    server: McpServer;\n    transport: StreamableHTTPServerTransport;\n  }> {\n    // Create a new transport for this request (stateless = no session management)\n    const transport = new StreamableHTTPServerTransport({\n      sessionIdGenerator: undefined,\n      enableJsonResponse:\n        this.options.streamableHttp?.enableJsonResponse || false,\n    });\n\n    // Create a new MCP server instance with dynamic capabilities\n    const capabilities = buildMcpCapabilities(\n      this.mcpModuleId,\n      this.toolRegistry,\n      this.options,\n    );\n    this.logger.debug(\n      `[Stateless] Built MCP capabilities: ${JSON.stringify(capabilities)}`,\n    );\n\n    const server = new McpServer(\n      { name: this.options.name, version: this.options.version },\n      {\n        capabilities: capabilities,\n        instructions: this.options.instructions || '',\n      },\n    );\n\n    // Connect the transport to the MCP server first\n    await server.connect(transport);\n\n    // Now resolve the request-scoped tool executor service\n    const contextId = ContextIdFactory.getByRequest(rawReq);\n    const executor = await this.moduleRef.resolve(\n      McpExecutorService,\n      contextId,\n      { strict: true },\n    );\n\n    // Register request handlers after connection\n    this.logger.debug(\n      '[Stateless] Registering request handlers for stateless MCP server',\n    );\n    executor.registerRequestHandlers(server, rawReq);\n\n    return { server, transport };\n  }\n\n  /**\n   * Handle POST requests\n   */\n  async handlePostRequest(req: any, res: any, body: unknown): Promise<void> {\n    // Get the appropriate HTTP adapter for the request/response\n    const adapter = HttpAdapterFactory.getAdapter(req, res);\n    const adaptedReq = adapter.adaptRequest(req);\n    const adaptedRes = adapter.adaptResponse(res);\n    const sessionId = adaptedReq.headers['mcp-session-id'] as\n      | string\n      | undefined;\n\n    this.logger.debug(\n      `[${sessionId || 'No-Session'}] Received MCP request: ${JSON.stringify(body)}`,\n    );\n\n    try {\n      if (this.isStatelessMode) {\n        return this.handleStatelessRequest(adaptedReq, adaptedRes, body);\n      } else {\n        return this.handleStatefulRequest(adaptedReq, adaptedRes, body);\n      }\n    } catch (error) {\n      this.logger.error(\n        `[${sessionId || 'No-Session'}] Error handling MCP request: ${error}`,\n      );\n      if (!adaptedRes.headersSent) {\n        adaptedRes.status(500).json({\n          jsonrpc: '2.0',\n          error: {\n            code: -32603,\n            message: 'Internal server error',\n          },\n          id: null,\n        });\n      }\n    }\n  }\n\n  /**\n   * Handle requests in stateless mode\n   */\n  async handleStatelessRequest(\n    req: any,\n    res: HttpResponse,\n    body: unknown,\n  ): Promise<void> {\n    this.logger.debug(\n      `[Stateless] Handling stateless MCP request at ${req.url}`,\n    );\n\n    let server: McpServer | null = null;\n    let transport: StreamableHTTPServerTransport | null = null;\n\n    try {\n      // Create a new server and transport for each request\n      const stateless = await this.createStatelessServer(req);\n      server = stateless.server;\n      transport = stateless.transport;\n\n      // Handle the request\n      await transport.handleRequest(req.raw, res.raw, body);\n\n      // Clean up after response is sent\n      res.raw.on('finish', async () => {\n        this.logger.debug('[Stateless] Response sent, cleaning up');\n        try {\n          if (transport) await transport.close();\n          if (server) await server.close();\n        } catch (error) {\n          this.logger.error('[Stateless] Error cleaning up:', error);\n        }\n      });\n    } catch (error) {\n      this.logger.error(\n        `[Stateless] Error in stateless request handling: ${error}`,\n      );\n      // Clean up on error\n      try {\n        if (transport) await transport.close();\n        if (server) await server.close();\n      } catch (error) {\n        this.logger.error('[Stateless] Error cleaning up on error:', error);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Handle requests in stateful mode\n   */\n  async handleStatefulRequest(\n    req: HttpRequest,\n    res: HttpResponse,\n    body: unknown,\n  ): Promise<void> {\n    const sessionId = req.headers['mcp-session-id'] as string | undefined;\n\n    this.logger.debug(`[${sessionId || 'New'}] Handling stateful MCP request`);\n\n    // Case 1: New initialization request\n    if (!sessionId && this.isInitializeRequest(body)) {\n      // Validate it's not a batch with multiple requests\n      if (Array.isArray(body) && body.length > 1) {\n        res.status(400).json({\n          jsonrpc: '2.0',\n          error: {\n            code: -32600,\n            message:\n              'Invalid Request: Only one initialization request is allowed',\n          },\n          id: null,\n        });\n        return;\n      }\n\n      // Build capabilities\n      const capabilities = buildMcpCapabilities(\n        this.mcpModuleId,\n        this.toolRegistry,\n        this.options,\n      );\n\n      // Create MCP server\n      const mcpServer = new McpServer(\n        { name: this.options.name, version: this.options.version },\n        {\n          capabilities,\n          instructions: this.options.instructions || '',\n        },\n      );\n\n      // Create transport with session management\n      const transport = new StreamableHTTPServerTransport({\n        sessionIdGenerator:\n          this.options.streamableHttp?.sessionIdGenerator ||\n          (() => randomUUID()),\n        enableJsonResponse:\n          this.options.streamableHttp?.enableJsonResponse || false,\n        onsessioninitialized: async (sid: string) => {\n          this.logger.debug(`[${sid}] Session initialized, storing references`);\n          // Store all session data\n          this.transports[sid] = transport;\n          this.mcpServers[sid] = mcpServer;\n\n          // Resolve and store the executor for this session\n          const contextId = ContextIdFactory.getByRequest(req);\n          const executor = await this.moduleRef.resolve(\n            McpExecutorService,\n            contextId,\n            { strict: true },\n          );\n          this.executors[sid] = executor;\n\n          // Register request handlers ONCE during initialization\n          executor.registerRequestHandlers(mcpServer, req);\n        },\n        onsessionclosed: async (sid: string) => {\n          this.logger.debug(`[${sid}] Session closed via DELETE`);\n          await this.cleanupSession(sid);\n        },\n      });\n\n      // Connect transport to server\n      await mcpServer.connect(transport);\n\n      // Handle the initialization request\n      await transport.handleRequest(req.raw, res.raw, body);\n\n      this.logger.log(`[${transport.sessionId}] New session initialized`);\n      return;\n    }\n\n    // Case 2: Request with session ID\n    if (sessionId) {\n      // Check if session exists\n      if (!this.transports[sessionId]) {\n        this.logger.debug(`[${sessionId}] Session not found`);\n        res.status(404).json({\n          jsonrpc: '2.0',\n          error: {\n            code: -32001,\n            message: 'Session not found',\n          },\n          id: null,\n        });\n        return;\n      }\n\n      // Reject re-initialization attempts\n      if (this.isInitializeRequest(body)) {\n        res.status(400).json({\n          jsonrpc: '2.0',\n          error: {\n            code: -32600,\n            message: 'Invalid Request: Server already initialized',\n          },\n          id: null,\n        });\n        return;\n      }\n\n      // Use existing transport\n      const transport = this.transports[sessionId];\n\n      this.logger.debug(\n        `[${sessionId}] Handling request with existing session`,\n      );\n\n      // Handle the request with existing transport and handlers\n      await transport.handleRequest(req.raw, res.raw, body);\n      return;\n    }\n\n    // Case 3: No session ID and not initialization\n    res.status(400).json({\n      jsonrpc: '2.0',\n      error: {\n        code: -32000,\n        message: 'Bad Request: Mcp-Session-Id header is required',\n      },\n      id: null,\n    });\n  }\n\n  /**\n   * Handle GET requests for SSE streams\n   */\n  async handleGetRequest(req: any, res: any): Promise<void> {\n    const adapter = HttpAdapterFactory.getAdapter(req, res);\n    const adaptedReq = adapter.adaptRequest(req);\n    const adaptedRes = adapter.adaptResponse(res);\n\n    if (this.isStatelessMode) {\n      adaptedRes.status(405).json({\n        jsonrpc: '2.0',\n        error: {\n          code: -32000,\n          message: 'Method not allowed in stateless mode',\n        },\n        id: null,\n      });\n      return;\n    }\n\n    const sessionId = adaptedReq.headers['mcp-session-id'] as\n      | string\n      | undefined;\n\n    if (!sessionId) {\n      adaptedRes.status(400).json({\n        jsonrpc: '2.0',\n        error: {\n          code: -32000,\n          message: 'Bad Request: Mcp-Session-Id header is required',\n        },\n        id: null,\n      });\n      return;\n    }\n\n    if (!this.transports[sessionId]) {\n      this.logger.debug(`[${sessionId}] GET request - session not found`);\n      adaptedRes.status(404).json({\n        jsonrpc: '2.0',\n        error: {\n          code: -32001,\n          message: 'Session not found',\n        },\n        id: null,\n      });\n      return;\n    }\n\n    this.logger.debug(`[${sessionId}] Establishing SSE stream`);\n    const transport = this.transports[sessionId];\n    await transport.handleRequest(adaptedReq.raw, adaptedRes.raw);\n  }\n\n  /**\n   * Handle DELETE requests for terminating sessions\n   */\n  async handleDeleteRequest(req: any, res: any): Promise<void> {\n    const adapter = HttpAdapterFactory.getAdapter(req, res);\n    const adaptedReq = adapter.adaptRequest(req);\n    const adaptedRes = adapter.adaptResponse(res);\n\n    if (this.isStatelessMode) {\n      adaptedRes.status(405).json({\n        jsonrpc: '2.0',\n        error: {\n          code: -32000,\n          message: 'Method not allowed in stateless mode',\n        },\n        id: null,\n      });\n      return;\n    }\n\n    const sessionId = adaptedReq.headers['mcp-session-id'] as\n      | string\n      | undefined;\n\n    if (!sessionId) {\n      adaptedRes.status(400).json({\n        jsonrpc: '2.0',\n        error: {\n          code: -32000,\n          message: 'Bad Request: Mcp-Session-Id header is required',\n        },\n        id: null,\n      });\n      return;\n    }\n\n    if (!this.transports[sessionId]) {\n      this.logger.debug(`[${sessionId}] DELETE request - session not found`);\n      adaptedRes.status(404).json({\n        jsonrpc: '2.0',\n        error: {\n          code: -32001,\n          message: 'Session not found',\n        },\n        id: null,\n      });\n      return;\n    }\n\n    this.logger.debug(`[${sessionId}] Processing DELETE request`);\n    const transport = this.transports[sessionId];\n\n    // Let transport handle the DELETE request\n    // The onsessionclosed callback will handle cleanup\n    await transport.handleRequest(adaptedReq.raw, adaptedRes.raw);\n  }\n\n  /**\n   * Helper function to detect initialize requests\n   */\n  private isInitializeRequest(body: unknown): boolean {\n    if (Array.isArray(body)) {\n      return body.some(\n        (msg) =>\n          typeof msg === 'object' &&\n          msg !== null &&\n          'method' in msg &&\n          msg.method === 'initialize',\n      );\n    }\n    return (\n      typeof body === 'object' &&\n      body !== null &&\n      'method' in body &&\n      (body as any).method === 'initialize'\n    );\n  }\n\n  /**\n   * Clean up session resources\n   */\n  private async cleanupSession(sessionId: string): Promise<void> {\n    if (!sessionId || !this.transports[sessionId]) {\n      return;\n    }\n\n    this.logger.debug(`[${sessionId}] Cleaning up session`);\n\n    try {\n      // Close transport if still open\n      const transport = this.transports[sessionId];\n      if (transport) {\n        await transport.close();\n      }\n\n      // Close MCP server\n      const server = this.mcpServers[sessionId];\n      if (server) {\n        await server.close();\n      }\n\n      // Clean up all references\n      delete this.transports[sessionId];\n      delete this.mcpServers[sessionId];\n      delete this.executors[sessionId];\n    } catch (error) {\n      this.logger.error(`[${sessionId}] Error during cleanup:`, error);\n    }\n  }\n\n  /**\n   * Clean up all sessions on module destroy\n   */\n  async onModuleDestroy(): Promise<void> {\n    this.logger.log('Cleaning up all MCP sessions...');\n    const sessionIds = Object.keys(this.transports);\n\n    await Promise.all(\n      sessionIds.map((sessionId) => this.cleanupSession(sessionId)),\n    );\n\n    this.logger.log(`Cleaned up ${sessionIds.length} MCP sessions`);\n  }\n}\n"]}