"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var McpStreamableHttpService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.McpStreamableHttpService = void 0;
const common_1 = require("@nestjs/common");
const core_1 = require("@nestjs/core");
const crypto_1 = require("crypto");
const mcp_js_1 = require("@modelcontextprotocol/sdk/server/mcp.js");
const streamableHttp_js_1 = require("@modelcontextprotocol/sdk/server/streamableHttp.js");
const http_adapter_factory_1 = require("../adapters/http-adapter.factory");
const mcp_executor_service_1 = require("./mcp-executor.service");
const mcp_registry_service_1 = require("./mcp-registry.service");
const capabilities_builder_1 = require("../utils/capabilities-builder");
let McpStreamableHttpService = McpStreamableHttpService_1 = class McpStreamableHttpService {
    constructor(options, mcpModuleId, moduleRef, toolRegistry) {
        this.options = options;
        this.mcpModuleId = mcpModuleId;
        this.moduleRef = moduleRef;
        this.toolRegistry = toolRegistry;
        this.logger = new common_1.Logger(McpStreamableHttpService_1.name);
        this.transports = {};
        this.mcpServers = {};
        this.executors = {};
        this.isStatelessMode = !!options.streamableHttp?.statelessMode;
    }
    async createStatelessServer(rawReq) {
        const transport = new streamableHttp_js_1.StreamableHTTPServerTransport({
            sessionIdGenerator: undefined,
            enableJsonResponse: this.options.streamableHttp?.enableJsonResponse || false,
        });
        const capabilities = (0, capabilities_builder_1.buildMcpCapabilities)(this.mcpModuleId, this.toolRegistry, this.options);
        this.logger.debug(`[Stateless] Built MCP capabilities: ${JSON.stringify(capabilities)}`);
        const server = new mcp_js_1.McpServer({ name: this.options.name, version: this.options.version }, {
            capabilities: capabilities,
            instructions: this.options.instructions || '',
        });
        await server.connect(transport);
        const contextId = core_1.ContextIdFactory.getByRequest(rawReq);
        const executor = await this.moduleRef.resolve(mcp_executor_service_1.McpExecutorService, contextId, { strict: true });
        this.logger.debug('[Stateless] Registering request handlers for stateless MCP server');
        executor.registerRequestHandlers(server, rawReq);
        return { server, transport };
    }
    async handlePostRequest(req, res, body) {
        const adapter = http_adapter_factory_1.HttpAdapterFactory.getAdapter(req, res);
        const adaptedReq = adapter.adaptRequest(req);
        const adaptedRes = adapter.adaptResponse(res);
        const sessionId = adaptedReq.headers['mcp-session-id'];
        this.logger.debug(`[${sessionId || 'No-Session'}] Received MCP request: ${JSON.stringify(body)}`);
        try {
            if (this.isStatelessMode) {
                return this.handleStatelessRequest(adaptedReq, adaptedRes, body);
            }
            else {
                return this.handleStatefulRequest(adaptedReq, adaptedRes, body);
            }
        }
        catch (error) {
            this.logger.error(`[${sessionId || 'No-Session'}] Error handling MCP request: ${error}`);
            if (!adaptedRes.headersSent) {
                adaptedRes.status(500).json({
                    jsonrpc: '2.0',
                    error: {
                        code: -32603,
                        message: 'Internal server error',
                    },
                    id: null,
                });
            }
        }
    }
    async handleStatelessRequest(req, res, body) {
        this.logger.debug(`[Stateless] Handling stateless MCP request at ${req.url}`);
        let server = null;
        let transport = null;
        try {
            const stateless = await this.createStatelessServer(req);
            server = stateless.server;
            transport = stateless.transport;
            await transport.handleRequest(req.raw, res.raw, body);
            res.raw.on('finish', async () => {
                this.logger.debug('[Stateless] Response sent, cleaning up');
                try {
                    if (transport)
                        await transport.close();
                    if (server)
                        await server.close();
                }
                catch (error) {
                    this.logger.error('[Stateless] Error cleaning up:', error);
                }
            });
        }
        catch (error) {
            this.logger.error(`[Stateless] Error in stateless request handling: ${error}`);
            try {
                if (transport)
                    await transport.close();
                if (server)
                    await server.close();
            }
            catch (error) {
                this.logger.error('[Stateless] Error cleaning up on error:', error);
            }
            throw error;
        }
    }
    async handleStatefulRequest(req, res, body) {
        const sessionId = req.headers['mcp-session-id'];
        this.logger.debug(`[${sessionId || 'New'}] Handling stateful MCP request`);
        if (!sessionId && this.isInitializeRequest(body)) {
            if (Array.isArray(body) && body.length > 1) {
                res.status(400).json({
                    jsonrpc: '2.0',
                    error: {
                        code: -32600,
                        message: 'Invalid Request: Only one initialization request is allowed',
                    },
                    id: null,
                });
                return;
            }
            const capabilities = (0, capabilities_builder_1.buildMcpCapabilities)(this.mcpModuleId, this.toolRegistry, this.options);
            const mcpServer = new mcp_js_1.McpServer({ name: this.options.name, version: this.options.version }, {
                capabilities,
                instructions: this.options.instructions || '',
            });
            const transport = new streamableHttp_js_1.StreamableHTTPServerTransport({
                sessionIdGenerator: this.options.streamableHttp?.sessionIdGenerator ||
                    (() => (0, crypto_1.randomUUID)()),
                enableJsonResponse: this.options.streamableHttp?.enableJsonResponse || false,
                onsessioninitialized: async (sid) => {
                    this.logger.debug(`[${sid}] Session initialized, storing references`);
                    this.transports[sid] = transport;
                    this.mcpServers[sid] = mcpServer;
                    const contextId = core_1.ContextIdFactory.getByRequest(req);
                    const executor = await this.moduleRef.resolve(mcp_executor_service_1.McpExecutorService, contextId, { strict: true });
                    this.executors[sid] = executor;
                    executor.registerRequestHandlers(mcpServer, req);
                },
                onsessionclosed: async (sid) => {
                    this.logger.debug(`[${sid}] Session closed via DELETE`);
                    await this.cleanupSession(sid);
                },
            });
            await mcpServer.connect(transport);
            await transport.handleRequest(req.raw, res.raw, body);
            this.logger.log(`[${transport.sessionId}] New session initialized`);
            return;
        }
        if (sessionId) {
            if (!this.transports[sessionId]) {
                this.logger.debug(`[${sessionId}] Session not found`);
                res.status(404).json({
                    jsonrpc: '2.0',
                    error: {
                        code: -32001,
                        message: 'Session not found',
                    },
                    id: null,
                });
                return;
            }
            if (this.isInitializeRequest(body)) {
                res.status(400).json({
                    jsonrpc: '2.0',
                    error: {
                        code: -32600,
                        message: 'Invalid Request: Server already initialized',
                    },
                    id: null,
                });
                return;
            }
            const transport = this.transports[sessionId];
            this.logger.debug(`[${sessionId}] Handling request with existing session`);
            await transport.handleRequest(req.raw, res.raw, body);
            return;
        }
        res.status(400).json({
            jsonrpc: '2.0',
            error: {
                code: -32000,
                message: 'Bad Request: Mcp-Session-Id header is required',
            },
            id: null,
        });
    }
    async handleGetRequest(req, res) {
        const adapter = http_adapter_factory_1.HttpAdapterFactory.getAdapter(req, res);
        const adaptedReq = adapter.adaptRequest(req);
        const adaptedRes = adapter.adaptResponse(res);
        if (this.isStatelessMode) {
            adaptedRes.status(405).json({
                jsonrpc: '2.0',
                error: {
                    code: -32000,
                    message: 'Method not allowed in stateless mode',
                },
                id: null,
            });
            return;
        }
        const sessionId = adaptedReq.headers['mcp-session-id'];
        if (!sessionId) {
            adaptedRes.status(400).json({
                jsonrpc: '2.0',
                error: {
                    code: -32000,
                    message: 'Bad Request: Mcp-Session-Id header is required',
                },
                id: null,
            });
            return;
        }
        if (!this.transports[sessionId]) {
            this.logger.debug(`[${sessionId}] GET request - session not found`);
            adaptedRes.status(404).json({
                jsonrpc: '2.0',
                error: {
                    code: -32001,
                    message: 'Session not found',
                },
                id: null,
            });
            return;
        }
        this.logger.debug(`[${sessionId}] Establishing SSE stream`);
        const transport = this.transports[sessionId];
        await transport.handleRequest(adaptedReq.raw, adaptedRes.raw);
    }
    async handleDeleteRequest(req, res) {
        const adapter = http_adapter_factory_1.HttpAdapterFactory.getAdapter(req, res);
        const adaptedReq = adapter.adaptRequest(req);
        const adaptedRes = adapter.adaptResponse(res);
        if (this.isStatelessMode) {
            adaptedRes.status(405).json({
                jsonrpc: '2.0',
                error: {
                    code: -32000,
                    message: 'Method not allowed in stateless mode',
                },
                id: null,
            });
            return;
        }
        const sessionId = adaptedReq.headers['mcp-session-id'];
        if (!sessionId) {
            adaptedRes.status(400).json({
                jsonrpc: '2.0',
                error: {
                    code: -32000,
                    message: 'Bad Request: Mcp-Session-Id header is required',
                },
                id: null,
            });
            return;
        }
        if (!this.transports[sessionId]) {
            this.logger.debug(`[${sessionId}] DELETE request - session not found`);
            adaptedRes.status(404).json({
                jsonrpc: '2.0',
                error: {
                    code: -32001,
                    message: 'Session not found',
                },
                id: null,
            });
            return;
        }
        this.logger.debug(`[${sessionId}] Processing DELETE request`);
        const transport = this.transports[sessionId];
        await transport.handleRequest(adaptedReq.raw, adaptedRes.raw);
    }
    isInitializeRequest(body) {
        if (Array.isArray(body)) {
            return body.some((msg) => typeof msg === 'object' &&
                msg !== null &&
                'method' in msg &&
                msg.method === 'initialize');
        }
        return (typeof body === 'object' &&
            body !== null &&
            'method' in body &&
            body.method === 'initialize');
    }
    async cleanupSession(sessionId) {
        if (!sessionId || !this.transports[sessionId]) {
            return;
        }
        this.logger.debug(`[${sessionId}] Cleaning up session`);
        try {
            const transport = this.transports[sessionId];
            if (transport) {
                await transport.close();
            }
            const server = this.mcpServers[sessionId];
            if (server) {
                await server.close();
            }
            delete this.transports[sessionId];
            delete this.mcpServers[sessionId];
            delete this.executors[sessionId];
        }
        catch (error) {
            this.logger.error(`[${sessionId}] Error during cleanup:`, error);
        }
    }
    async onModuleDestroy() {
        this.logger.log('Cleaning up all MCP sessions...');
        const sessionIds = Object.keys(this.transports);
        await Promise.all(sessionIds.map((sessionId) => this.cleanupSession(sessionId)));
        this.logger.log(`Cleaned up ${sessionIds.length} MCP sessions`);
    }
};
exports.McpStreamableHttpService = McpStreamableHttpService;
exports.McpStreamableHttpService = McpStreamableHttpService = McpStreamableHttpService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, common_1.Inject)('MCP_OPTIONS')),
    __param(1, (0, common_1.Inject)('MCP_MODULE_ID')),
    __metadata("design:paramtypes", [Object, String, core_1.ModuleRef,
        mcp_registry_service_1.McpRegistryService])
], McpStreamableHttpService);
//# sourceMappingURL=mcp-streamable-http.service.js.map