"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var McpToolsHandler_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.McpToolsHandler = void 0;
const types_js_1 = require("@modelcontextprotocol/sdk/types.js");
const common_1 = require("@nestjs/common");
const core_1 = require("@nestjs/core");
const zod_to_json_schema_1 = require("zod-to-json-schema");
const mcp_registry_service_1 = require("../mcp-registry.service");
const mcp_handler_base_1 = require("./mcp-handler.base");
let McpToolsHandler = McpToolsHandler_1 = class McpToolsHandler extends mcp_handler_base_1.McpHandlerBase {
    constructor(moduleRef, registry, mcpModuleId) {
        super(moduleRef, registry, McpToolsHandler_1.name);
        this.mcpModuleId = mcpModuleId;
    }
    buildDefaultContentBlock(result) {
        return [
            {
                type: 'text',
                text: JSON.stringify(result, null, 2),
            },
        ];
    }
    formatToolResult(result, outputSchema) {
        if (result && typeof result === 'object' && Array.isArray(result.content)) {
            return result;
        }
        if (outputSchema) {
            const validation = outputSchema.safeParse(result);
            if (!validation.success) {
                throw new types_js_1.McpError(types_js_1.ErrorCode.InternalError, `Tool result does not match outputSchema: ${validation.error.message}`);
            }
            return {
                structuredContent: result,
                content: this.buildDefaultContentBlock(result),
            };
        }
        return {
            content: this.buildDefaultContentBlock(result),
        };
    }
    registerHandlers(mcpServer, httpRequest) {
        if (this.registry.getTools(this.mcpModuleId).length === 0) {
            this.logger.debug('No tools registered, skipping tool handlers');
            return;
        }
        mcpServer.server.setRequestHandler(types_js_1.ListToolsRequestSchema, () => {
            const tools = this.registry.getTools(this.mcpModuleId).map((tool) => {
                const toolSchema = {
                    name: tool.metadata.name,
                    description: tool.metadata.description,
                    annotations: tool.metadata.annotations,
                    _meta: tool.metadata._meta,
                };
                if (tool.metadata.parameters) {
                    toolSchema['inputSchema'] = (0, zod_to_json_schema_1.zodToJsonSchema)(tool.metadata.parameters);
                }
                if (tool.metadata.outputSchema) {
                    const outputSchema = (0, zod_to_json_schema_1.zodToJsonSchema)(tool.metadata.outputSchema);
                    const jsonSchema = {
                        ...outputSchema,
                        type: 'object',
                    };
                    toolSchema['outputSchema'] = jsonSchema;
                }
                return toolSchema;
            });
            return {
                tools,
            };
        });
        mcpServer.server.setRequestHandler(types_js_1.CallToolRequestSchema, async (request) => {
            this.logger.debug('CallToolRequestSchema is being called');
            const toolInfo = this.registry.findTool(this.mcpModuleId, request.params.name);
            if (!toolInfo) {
                throw new types_js_1.McpError(types_js_1.ErrorCode.MethodNotFound, `Unknown tool: ${request.params.name}`);
            }
            try {
                if (toolInfo.metadata.parameters) {
                    const validation = toolInfo.metadata.parameters.safeParse(request.params.arguments || {});
                    if (!validation.success) {
                        throw new types_js_1.McpError(types_js_1.ErrorCode.InvalidParams, `Invalid parameters: ${validation.error.message}`);
                    }
                    request.params.arguments = validation.data;
                }
                const contextId = core_1.ContextIdFactory.getByRequest(httpRequest);
                this.moduleRef.registerRequestByContextId(httpRequest, contextId);
                const toolInstance = await this.moduleRef.resolve(toolInfo.providerClass, contextId, { strict: false });
                const context = this.createContext(mcpServer, request);
                if (!toolInstance) {
                    throw new types_js_1.McpError(types_js_1.ErrorCode.MethodNotFound, `Unknown tool: ${request.params.name}`);
                }
                const result = await toolInstance[toolInfo.methodName].call(toolInstance, request.params.arguments, context, httpRequest.raw);
                const transformedResult = this.formatToolResult(result, toolInfo.metadata.outputSchema);
                this.logger.debug(transformedResult, 'CallToolRequestSchema result');
                return transformedResult;
            }
            catch (error) {
                this.logger.error(error);
                if (error instanceof types_js_1.McpError) {
                    throw error;
                }
                return {
                    content: [{ type: 'text', text: error.message }],
                    isError: true,
                };
            }
        });
    }
};
exports.McpToolsHandler = McpToolsHandler;
exports.McpToolsHandler = McpToolsHandler = McpToolsHandler_1 = __decorate([
    (0, common_1.Injectable)({ scope: common_1.Scope.REQUEST }),
    __param(2, (0, common_1.Inject)('MCP_MODULE_ID')),
    __metadata("design:paramtypes", [core_1.ModuleRef,
        mcp_registry_service_1.McpRegistryService, String])
], McpToolsHandler);
//# sourceMappingURL=mcp-tools.handler.js.map