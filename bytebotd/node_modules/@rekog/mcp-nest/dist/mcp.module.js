"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var McpModule_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.McpModule = void 0;
const common_1 = require("@nestjs/common");
const core_1 = require("@nestjs/core");
const interfaces_1 = require("./interfaces");
const mcp_executor_service_1 = require("./services/mcp-executor.service");
const mcp_registry_service_1 = require("./services/mcp-registry.service");
const sse_ping_service_1 = require("./services/sse-ping.service");
const sse_controller_factory_1 = require("./transport/sse.controller.factory");
const stdio_service_1 = require("./transport/stdio.service");
const streamable_http_controller_factory_1 = require("./transport/streamable-http.controller.factory");
const normalize_endpoint_1 = require("./utils/normalize-endpoint");
let instanceIdCounter = 0;
let McpModule = McpModule_1 = class McpModule {
    constructor() {
        this.__isMcpModule = true;
    }
    static forRoot(options) {
        const defaultOptions = {
            transport: [
                interfaces_1.McpTransportType.SSE,
                interfaces_1.McpTransportType.STREAMABLE_HTTP,
                interfaces_1.McpTransportType.STDIO,
            ],
            sseEndpoint: 'sse',
            messagesEndpoint: 'messages',
            mcpEndpoint: 'mcp',
            guards: [],
            decorators: [],
            streamableHttp: {
                enableJsonResponse: true,
                sessionIdGenerator: undefined,
                statelessMode: true,
            },
            sse: {
                pingEnabled: true,
                pingIntervalMs: 30000,
            },
        };
        const mergedOptions = { ...defaultOptions, ...options };
        mergedOptions.sseEndpoint = (0, normalize_endpoint_1.normalizeEndpoint)(mergedOptions.sseEndpoint);
        mergedOptions.messagesEndpoint = (0, normalize_endpoint_1.normalizeEndpoint)(mergedOptions.messagesEndpoint);
        mergedOptions.mcpEndpoint = (0, normalize_endpoint_1.normalizeEndpoint)(mergedOptions.mcpEndpoint);
        const moduleId = `mcp-module-${instanceIdCounter++}`;
        const providers = this.createProvidersFromOptions(mergedOptions, moduleId);
        const controllers = this.createControllersFromOptions(mergedOptions);
        return {
            module: McpModule_1,
            controllers,
            providers,
            exports: [mcp_registry_service_1.McpRegistryService],
        };
    }
    static createControllersFromOptions(options) {
        const sseEndpoint = options.sseEndpoint ?? 'sse';
        const messagesEndpoint = options.messagesEndpoint ?? 'messages';
        const mcpEndpoint = options.mcpEndpoint ?? 'mcp';
        const guards = options.guards ?? [];
        const transports = Array.isArray(options.transport)
            ? options.transport
            : [options.transport ?? interfaces_1.McpTransportType.SSE];
        const controllers = [];
        const decorators = options.decorators ?? [];
        if (transports.includes(interfaces_1.McpTransportType.SSE)) {
            const sseController = (0, sse_controller_factory_1.createSseController)(sseEndpoint, messagesEndpoint, guards, decorators);
            controllers.push(sseController);
        }
        if (transports.includes(interfaces_1.McpTransportType.STREAMABLE_HTTP)) {
            const streamableHttpController = (0, streamable_http_controller_factory_1.createStreamableHttpController)(mcpEndpoint, guards, decorators);
            controllers.push(streamableHttpController);
        }
        if (transports.includes(interfaces_1.McpTransportType.STDIO)) {
        }
        return controllers;
    }
    static createProvidersFromOptions(options, moduleId) {
        const providers = [
            {
                provide: 'MCP_OPTIONS',
                useValue: options,
            },
            {
                provide: 'MCP_MODULE_ID',
                useValue: moduleId,
            },
            mcp_registry_service_1.McpRegistryService,
            mcp_executor_service_1.McpExecutorService,
        ];
        const transports = Array.isArray(options.transport)
            ? options.transport
            : [options.transport ?? interfaces_1.McpTransportType.SSE];
        if (transports.includes(interfaces_1.McpTransportType.SSE)) {
            providers.push(sse_ping_service_1.SsePingService);
        }
        if (transports.includes(interfaces_1.McpTransportType.STDIO)) {
            providers.push(stdio_service_1.StdioService);
        }
        return providers;
    }
};
exports.McpModule = McpModule;
exports.McpModule = McpModule = McpModule_1 = __decorate([
    (0, common_1.Module)({
        imports: [core_1.DiscoveryModule],
        providers: [mcp_registry_service_1.McpRegistryService, mcp_executor_service_1.McpExecutorService],
    })
], McpModule);
//# sourceMappingURL=mcp.module.js.map